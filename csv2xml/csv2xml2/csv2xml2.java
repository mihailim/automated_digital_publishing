/* Copyright (C) 2014-2018 dralagen, Stephan Kreutzer
 *
 * This file is part of csv2xml2.
 *
 * csv2xml2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * csv2xml2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with csv2xml2. If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file $/csv2xml/csv2xml2.java
 * @author dralagen, Stephan Kreutzer
 * @since 2014-11-14
 */

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Comment;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.util.*;
import org.xml.sax.SAXException;
import java.net.URLDecoder;

/**
 * Created on 14/11/14.
 */
public class csv2xml2 {

    private DocumentBuilder domBuilder = null;

    private Document document;

    private Node currentElement;

    private Map<Integer, String> mapping = null;

    private boolean compact = false;

    private int indentSize = 4;

    private int columnCount = 0;

    public csv2xml2() {
        try {
            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
            domBuilder = domFactory.newDocumentBuilder();
        } catch (FactoryConfigurationError exp) {
            System.err.println(exp.toString());
        } catch (ParserConfigurationException exp) {
            System.err.println(exp.toString());
        } catch (Exception exp) {
            System.err.println(exp.toString());
        }
    }

    /**
     * Create a new document
     *
     * If the document already exist, it will be erased
     *
     * @param[in] rootName name of root node
     * @param[in] encapsulationName specifies the name of the element that will
     *     encapsulate all rows that get converted.
     */
    public void createNewDocument(String rootName, String encapsulationName) {

        document = domBuilder.newDocument();

        // Root element
        Element element = null;

        try
        {
            element = document.createElement(rootName);
        }
        catch (org.w3c.dom.DOMException e)
        {
            if (e.code == org.w3c.dom.DOMException.INVALID_CHARACTER_ERR)
            {
                System.out.println("csv2xml2: '" + rootName + "' isn't a valid XML root tag name. Please check the 'root-tag-name' setting in the configuration file.");
            }

            throw e;
        }

        document.appendChild(element);

        Comment comment = document.createComment(" This file was generated by csv2xml2, which is free software licensed under the GNU Affero General Public License 3 or any later version (see https://github.com/publishing-systems/automated_digital_publishing/ and http://www.publishing-systems.org). ");
        document.insertBefore(comment, element);

        currentElement = element;

        try
        {
            element = document.createElement(encapsulationName);
        }
        catch (org.w3c.dom.DOMException e)
        {
            if (e.code == org.w3c.dom.DOMException.INVALID_CHARACTER_ERR)
            {
                System.out.println("csv2xml2: '" + encapsulationName + "' isn't a valid XML tag name. Please check the 'encapsulation-tag-name' setting in the configuration file.");
            }

            throw e;
        }

        currentElement.appendChild(element);
        currentElement = element;
    }

    /**
     * Move your cursor of current element to parent node
     */
    public void parent() {
        currentElement = currentElement.getParentNode();
    }

    /**
     * Convert the csv input stream into a internal document xml
     *
     * @param csv InputStream contain your csv file
     * @param configFile Configuration file contains settings for the conversion.
     * @return number of rows converted
     */
    public int convert(InputStream csv, File configFile) {

        this.mapping = null;

        String delimiter = null;
        boolean ignoreFirstLine = false;
        String rootTagName = null;
        String encapsulationTagName = null;
        String rowTagName = null;

        try
        {
            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            Document document = documentBuilder.parse(configFile);
            document.getDocumentElement().normalize();

            NodeList rootNodeList = document.getElementsByTagName("csv2xml2-config");

            if (rootNodeList.getLength() <= 0)
            {
                System.out.println("csv2xml2: Configuration file '" + configFile.getAbsolutePath() + "' seems to be invalid.");
                System.exit(-1);
            }

            NodeList rootSubNodeList = rootNodeList.item(0).getChildNodes();

            for (int i = 0; i < rootSubNodeList.getLength(); i++)
            {
                Node rootSubNode = rootSubNodeList.item(i);

                if (rootSubNode.getNodeName().equalsIgnoreCase("delimiter") == true)
                {
                    if (delimiter != null)
                    {
                        System.out.println("csv2xml2: CSV delimiter specified more than once in '" + configFile.getAbsolutePath() + "' configuration file.");
                        System.exit(-1);
                    }

                    delimiter = rootSubNode.getTextContent();
                }
                else if (rootSubNode.getNodeName().equalsIgnoreCase("ignore-first-line") == true)
                {
                    String ignoreFirstLineString = rootSubNode.getTextContent();

                    if (ignoreFirstLineString.length() > 0)
                    {
                        if (ignoreFirstLineString.equalsIgnoreCase("false") != true &&
                            ignoreFirstLineString.equalsIgnoreCase("0") != true)
                        {
                            ignoreFirstLine = true;
                        }
                    }
                }
                else if (rootSubNode.getNodeName().equalsIgnoreCase("root-tag-name") == true)
                {
                    if (rootTagName != null)
                    {
                        System.out.println("csv2xml2: Output root tag name specified more than once in '" + configFile.getAbsolutePath() + "' configuration file.");
                        System.exit(-1);
                    }

                    rootTagName = rootSubNode.getTextContent();
                }
                else if (rootSubNode.getNodeName().equalsIgnoreCase("encapsulation-tag-name") == true)
                {
                    if (encapsulationTagName != null)
                    {
                        System.out.println("csv2xml2: Output data encapsulation tag name specified more than once in '" + configFile.getAbsolutePath() + "' configuration file.");
                        System.exit(-1);
                    }

                    encapsulationTagName = rootSubNode.getTextContent();
                }
                else if (rootSubNode.getNodeName().equalsIgnoreCase("row-tag-name") == true)
                {
                    if (rowTagName != null)
                    {
                        System.out.println("csv2xml2: Output row tag name specified more than once in '" + configFile.getAbsolutePath() + "' configuration file.");
                        System.exit(-1);
                    }

                    rowTagName = rootSubNode.getTextContent();
                }
                else if (rootSubNode.getNodeName().equalsIgnoreCase("mapping") == true)
                {
                    if (this.mapping == null)
                    {
                        this.mapping = new HashMap<Integer, String>();
                    }
                    else
                    {
                        System.out.println("csv2xml2: CSV column to XML tag name mapping specified more than once in '" + configFile.getAbsolutePath() + "' configuration file.");
                        System.exit(-1);
                    }

                    NodeList mappingSubNodeList = rootSubNode.getChildNodes();

                    for (int j = 0; j < mappingSubNodeList.getLength(); j++)
                    {
                        Node mappingSubNode = mappingSubNodeList.item(j);

                        if (mappingSubNode.getNodeName().equalsIgnoreCase("csv-column") == true)
                        {
                            NamedNodeMap csvColumnNodeAttributes = mappingSubNode.getAttributes();

                            if (csvColumnNodeAttributes == null)
                            {
                                System.out.print("csv2xml2: CSV column mapping entry #" + (j + 1) + " in '" + configFile.getAbsolutePath() + "' configuration file has no attributes.\n");
                                System.exit(-1);
                            }

                            Node numberAttribute = csvColumnNodeAttributes.getNamedItem("number");

                            if (numberAttribute == null)
                            {
                                System.out.print("csv2xml2: CSV column mapping entry #" + (j + 1) + " in '" + configFile.getAbsolutePath() + "' configuration file is missing the 'number' attribute.\n");
                                System.exit(-1);
                            }

                            int number = 0;

                            try
                            {
                                number = Integer.parseInt(numberAttribute.getTextContent());
                            }
                            catch (NumberFormatException ex)
                            {
                                System.out.print("csv2xml2: CSV column mapping entry #" + (j + 1) + " in '" + configFile.getAbsolutePath() + "' configuration file doesn't contain an integer in the 'number' attribute.\n");
                                System.exit(-1);
                            }

                            if (number < 0)
                            {
                                System.out.print("csv2xml2: CSV column number " + number + " of mapping entry #" + (j + 1) + " in '" + configFile.getAbsolutePath() + "' configuration file is negative.\n");
                                System.exit(-1);
                            }

                            if (this.mapping.containsKey(number) == true)
                            {
                                System.out.print("csv2xml2: CSV column in '" + configFile.getAbsolutePath() + "' configuration file mapped more than once.\n");
                                System.exit(-1);
                            }

                            Node xmlTagNameAttribute = csvColumnNodeAttributes.getNamedItem("xml-tag-name");

                            if (xmlTagNameAttribute == null)
                            {
                                System.out.print("csv2xml2: CSV column mapping entry #" + (j + 1) + " in '" + configFile.getAbsolutePath() + "' configuration file is missing the 'xml-tag-name' attribute.\n");
                                System.exit(-1);
                            }

                            this.mapping.put(number, xmlTagNameAttribute.getTextContent());
                        }
                    }
                }
            }
        }
        catch (ParserConfigurationException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }
        catch (SAXException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }

        if (delimiter == null)
        {
            System.out.println("csv2xml2: No CSV delimiter specified in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (delimiter.length() <= 0)
        {
            System.out.println("csv2xml2: CSV delimiter specification is empty in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (this.mapping == null)
        {
            System.out.println("csv2xml2: CSV column mapping is missing in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (this.mapping.isEmpty() == true)
        {
            System.out.println("csv2xml2: CSV column mapping is empty in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (rootTagName == null)
        {
            System.out.println("csv2xml2: No output root tag name specified in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (rootTagName.length() <= 0)
        {
            System.out.println("csv2xml2: Output root tag name specification is empty in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (encapsulationTagName == null)
        {
            System.out.println("csv2xml2: No output data encapsulation tag name specified in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (encapsulationTagName.length() <= 0)
        {
            System.out.println("csv2xml2: Output data encapsulation tag name specification is empty in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (rowTagName == null)
        {
            System.out.println("csv2xml2: No output row tag name specified in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }

        if (rowTagName.length() <= 0)
        {
            System.out.println("csv2xml2: Output row tag name specification is empty in '" + configFile.getAbsolutePath() + "' configuration file.");
            System.exit(-1);
        }


        this.createNewDocument(rootTagName, encapsulationTagName);


        int rowsCount = 0;
        try {
            // Read csv file
            LineNumberReader csvReader;
            csvReader = new LineNumberReader(new InputStreamReader(csv, "UTF-8"));

            {  // Data rows
                List<String> rowValues = null;

                if (ignoreFirstLine == true)
                {
                    split(csvReader, delimiter);
                }

                while ( (rowValues = split(csvReader, delimiter)) != null ) {

                    Element rowElement = null;

                    try
                    {
                        rowElement = document.createElement(rowTagName);
                    }
                    catch (org.w3c.dom.DOMException e)
                    {
                        if (e.code == org.w3c.dom.DOMException.INVALID_CHARACTER_ERR)
                        {
                            System.out.println("csv2xml2: '" + rowTagName + "' isn't a valid XML tag name. Please check the 'row-tag-name' setting in the '" + configFile.getAbsolutePath() + "' configuration file.");
                        }

                        throw e;
                    }

                    currentElement.appendChild(rowElement);

                    for (Map.Entry<Integer, String> columnMapping : this.mapping.entrySet())
                    {
                        String value = "";

                        if (columnMapping.getKey() >= 0 && columnMapping.getKey() < rowValues.size())
                        {
                            value = rowValues.get(columnMapping.getKey());
                        }
                        else
                        {
                            System.out.println("csv2xml2: The column number " + columnMapping.getKey() + " of the CSV column mapping doesn't exist in the input file.");
                            System.exit(-1);
                        }

                        Element curElement;

                        try
                        {
                            curElement = document.createElement(columnMapping.getValue());
                        }
                        catch (org.w3c.dom.DOMException e)
                        {
                            if (e.code == org.w3c.dom.DOMException.INVALID_CHARACTER_ERR)
                            {
                                System.out.println("csv2xml2: '" + columnMapping.getValue() + "' isn't a valid XML tag name. Please check the CSV column mapping for column " + columnMapping.getKey() + " in the '" + configFile.getAbsolutePath() + "' configuration file.");
                            }

                            throw e;
                        }

                        curElement.appendChild(document.createTextNode(value.replaceAll("\"\"", "\"")));
                        rowElement.appendChild(curElement);
                    }

                    rowsCount++;
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        return rowsCount;
        // "XML Document has been created" + rowsCount;
    }

    /**
     * Write the xml document in out
     *
     * You can use <code>writeTo(System.out)</code> to write the xml result into your console
     *
     * @param out Write the xml document in output
     */
    public void writeTo(OutputStream out) {
        ByteArrayOutputStream baos = null;
        OutputStreamWriter osw = null;

        try {

            baos = new ByteArrayOutputStream();
            osw = new OutputStreamWriter(baos, "UTF-8");

            TransformerFactory tranFactory = TransformerFactory.newInstance();
            Transformer aTransformer = tranFactory.newTransformer();
            aTransformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            aTransformer.setOutputProperty(OutputKeys.INDENT, (isCompact())?"no":"yes");
            aTransformer.setOutputProperty(OutputKeys.METHOD, "xml");
            aTransformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", String.valueOf(indentSize));

            Source src = new DOMSource(document);
            Result result = new StreamResult(osw);
            aTransformer.transform(src, result);

            osw.flush();
            String output = new String(baos.toByteArray(), "UTF-8");
            out.write(output.getBytes("UTF-8"));

        } catch (Exception exp) {
            exp.printStackTrace();
        } finally {
            if (osw != null) {
                try {
                    osw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (baos != null) {
                try {
                    baos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private List<String> split(LineNumberReader reader, String delimiter) throws IOException {
        return split(reader, delimiter, false);
    }

    private List<String> split(LineNumberReader reader, String delimiter, boolean fieldOpened) throws IOException {

        boolean wasFieldOpened = fieldOpened;
        String text = reader.readLine();

        if (text == null) {
            return null;
        }

        // text.split(delimiter) delete end empty field
        String[] splited =  text.split(delimiter, Integer.MAX_VALUE);

        List<String> result = new ArrayList<String>();

        int i = 0;
        while (i < splited.length) {
            int j = i;

            String field = splited[i];

            // find a complex field with delimiter character or multiline
            if (!field.equals("")
                    && (field.charAt(0) == '"' || fieldOpened)
                    && (field.charAt(field.length() - 1) != '"')) {

                if (!fieldOpened && field.length() > 1 && field.charAt(1) != '"') {
                    // delete the " unnecessary
                    field = field.substring(1);
                    fieldOpened = true;
                }

                if (fieldOpened) {
                    ++j;
                    if (j < splited.length) {
                        while (j < splited.length
                                && (splited[j].equals("") || splited[j].charAt(splited[j].length() - 1) != '"')
                                ) {
                            field += delimiter + splited[j];
                            ++j;
                        }
                    }

                    // we find the end field
                    if (j < splited.length) {
                        field += delimiter + splited[j];
                        field = field.substring(0, field.length() - 2);
                        fieldOpened = false;
                    }
                }
            }

            // we find a quote field
            if (!field.equals("")
                    && (fieldOpened || field.charAt(0) == '"')
                    && field.charAt(field.length()-1) == '"') {

                int startIndex = (fieldOpened) ? 0 : 1;
                result.add(field.substring(startIndex, Math.max(field.length() - 1, 1)));
                fieldOpened = false;
            }
            else {
                result.add(field);
            }
            i = j+1;
        }


        // complete line who field contain '\n'
        if ( fieldOpened == true ) {
            List<String> extendsRowValues = null;
            if ((extendsRowValues = split(reader, delimiter, fieldOpened)) != null) {

                int rowValuesLastIndex = result.size() - 1;

                result.set(rowValuesLastIndex, result.get(rowValuesLastIndex) + "\n" + extendsRowValues.get(0));

                if ( extendsRowValues.size() > 1 ) {
                    result.addAll(extendsRowValues.subList(1, extendsRowValues.size()));
                }

                return result;
            }
        }

        if (wasFieldOpened == false)
        {
            if (this.columnCount == 0)
            {
                this.columnCount = result.size();

                for (Map.Entry<Integer, String> columnMapping : this.mapping.entrySet())
                {
                    if (columnMapping.getKey() < 0 || columnMapping.getKey() > (this.columnCount - 1))
                    {
                        System.out.println("csv2xml2: The column number " + columnMapping.getKey() + " of the CSV column mapping doesn't exist in the input file.");
                        System.exit(-1);
                    }
                }
            }
            else
            {
                if (this.columnCount != result.size())
                {
                    System.out.println("csv2xml2: Different column count in CSV row/line " + reader.getLineNumber() + ".");
                    System.exit(-1);
                }
            }
        }

        return result;
    }

    public boolean isCompact() {
        return compact;
    }

    public void setCompact(boolean compact) {
        this.compact = compact;
    }

    public int getIndentSize() {
        return indentSize;
    }

    public void setIndentSize(int indentSize) {
        this.indentSize = (indentSize > 0) ? indentSize : 0;
    }

    /**
     * Create an InputStream form a path of fileSystem
     *
     * @see java.io.FileInputStream
     *
     * @param inputName is a path of file
     * @return InputStream from inputName
     * @throws java.io.IOException if a error in read the input
     */
    public static InputStream getInputStream(String inputName) throws IOException {
        InputStream inputStream = new FileInputStream(new File(inputName));

        return inputStream;
    }

    public static void main (String[] args) {

        System.out.print("csv2xml2 Copyright (C) 2014-2018 dralagen, Stephan Kreutzer\n" +
                         "This program comes with ABSOLUTELY NO WARRANTY.\n" +
                         "This is free software, and you are welcome to redistribute it\n" +
                         "under certain conditions. See the GNU Affero General Public\n" +
                         "License, either version 3 of the License, or (at your option) any\n" +
                         "later version for details. Also, see the source code repository\n" +
                         "https://github.com/publishing-systems/automated_digital_publishing/\n" +
                         "or the project website http://www.publishing-systems.org.\n\n");

        if (args.length != 3) {
            System.out.println("Usage:\n" +
                               "\tcsv2xml2 \"in-file.csv\" \"config-file.xml\" \"out-file.xml\"\n");
            System.exit(1);
        }

        String programPath = csv2xml2.class.getProtectionDomain().getCodeSource().getLocation().getPath();

        try
        {
            programPath = new File(programPath).getCanonicalPath() + File.separator;
            programPath = URLDecoder.decode(programPath, "UTF-8");
        }
        catch (UnsupportedEncodingException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
            System.exit(-1);
        }

        File configFile = new File(args[1]);

        if (configFile.exists() != true)
        {
            System.out.print("csv2xml2: '" + configFile.getAbsolutePath() + "' doesn't exist.\n");
            System.exit(-1);
        }

        if (configFile.isFile() != true)
        {
            System.out.print("csv2xml2: '" + configFile.getAbsolutePath() + "' isn't a file.\n");
            System.exit(-1);
        }

        if (configFile.canRead() != true)
        {
            System.out.print("csv2xml2: '" + configFile.getAbsolutePath() + "' isn't readable.\n");
            System.exit(-1);
        }


        csv2xml2 converter = new csv2xml2();

        InputStream csvInput = null;
        try {
            csvInput = csv2xml2.getInputStream(args[0]);
        } catch (IOException e) {
            e.printStackTrace();
        }

        converter.convert(csvInput, configFile);

        //converter.writeTo(System.out);

        OutputStream xmlOutput;
        try {
            xmlOutput = new FileOutputStream(args[2]);

            converter.writeTo(xmlOutput);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}

